/*
          # [إعادة تعيين كاملة لبنية قاعدة البيانات]
          هذا السكربت سيقوم بحذف جميع الجداول والدوال والسياسات المتعلقة بالتطبيق وإعادة بنائها من جديد.
          
          ## تنبيه هام:
          - **فقدان البيانات**: سيتم حذف جميع البيانات الموجودة في جداول التطبيق (المستخدمين، المحادثات، الرسائل).
          - **إجراء وقائي**: يوصى بأخذ نسخة احتياطية من بياناتك إذا كانت تحتوي على معلومات هامة قبل تشغيل هذا السكربت.
          
          ## Metadata:
          - Schema-Category: "Dangerous"
          - Impact-Level: "High"
          - Requires-Backup: true
          - Reversible: false
          
          ## Structure Details:
          - سيتم حذف وإعادة إنشاء الجداول: profiles, conversations, conversation_members, messages.
          - سيتم حذف وإعادة إنشاء الدوال: handle_new_user, get_user_conversations, get_conversation_partner, create_private_conversation.
          - سيتم حذف وإعادة إنشاء جميع سياسات الأمان (RLS).
          - سيتم حذف وإعادة إنشاء مخزن الصور (avatars).
*/

-- ==========[ المرحلة الأولى: الحذف الآمن للعناصر السابقة ]==========

-- حذف السياسات الأمنية (Policies) أولاً لتجنب مشاكل الاعتمادية
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can view conversations they are a member of." ON public.conversations;
DROP POLICY IF EXISTS "Users can view members of their conversations." ON public.conversation_members;
DROP POLICY IF EXISTS "Users can insert their own messages." ON public.messages;
DROP POLICY IF EXISTS "Users can view messages in their conversations." ON public.messages;
DROP POLICY IF EXISTS "Avatar images are publicly accessible." ON storage.objects;
DROP POLICY IF EXISTS "Anyone can upload an avatar." ON storage.objects;

-- حذف المُشغِّل (Trigger)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- حذف الدوال (Functions)
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.get_user_conversations();
DROP FUNCTION IF EXISTS public.get_conversation_partner(uuid);
DROP FUNCTION IF EXISTS public.create_private_conversation(uuid);

-- حذف الجداول (Tables) باستخدام CASCADE لحذف أي اعتماديات متبقية
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.conversation_members CASCADE;
DROP TABLE IF EXISTS public.conversations CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- حذف مخزن الصور (Bucket)
-- ملاحظة: حذف المخزن يحذف جميع الملفات بداخله
SELECT storage.empty_bucket('avatars');
SELECT storage.delete_bucket('avatars');


-- ==========[ المرحلة الثانية: إعادة بناء البنية بالكامل ]==========

-- 1. إنشاء جدول المستخدمين (profiles)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL PRIMARY KEY,
  updated_at TIMESTAMP WITH TIME ZONE,
  username TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  status TEXT DEFAULT 'مرحباً، أستخدم وصل!',
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);
COMMENT ON TABLE public.profiles IS 'Profile information for each user.';

-- 2. إنشاء جدول المحادثات (conversations)
CREATE TABLE public.conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  type TEXT CHECK (type IN ('private', 'group')) DEFAULT 'private'
);
COMMENT ON TABLE public.conversations IS 'Stores conversation metadata.';

-- 3. إنشاء جدول أعضاء المحادثات (conversation_members)
CREATE TABLE public.conversation_members (
  conversation_id UUID REFERENCES public.conversations(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (conversation_id, user_id)
);
COMMENT ON TABLE public.conversation_members IS 'Links users to conversations.';

-- 4. إنشاء جدول الرسائل (messages)
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  content TEXT,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  conversation_id UUID REFERENCES public.conversations(id) ON DELETE CASCADE,
  message_type TEXT DEFAULT 'text'
);
COMMENT ON TABLE public.messages IS 'Stores messages for each conversation.';

-- 5. إنشاء دالة لإنشاء ملف شخصي تلقائي عند تسجيل مستخدم جديد
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, username, avatar_url)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    new.raw_user_meta_data->>'avatar_url'
  );
  RETURN new;
END;
$$;
COMMENT ON FUNCTION public.handle_new_user() IS 'Creates a profile for a new user.';

-- 6. إنشاء المُشغِّل (Trigger) الذي يستدعي الدالة
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 7. إنشاء مخزن الصور (Storage Bucket)
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;
COMMENT ON TABLE storage.buckets IS 'Stores user avatar images.';

-- 8. تفعيل "أمان على مستوى الصف" (Row Level Security - RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversation_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- 9. إنشاء سياسات الأمان (Policies)
-- سياسات جدول profiles
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Profiles are public to authenticated users." ON public.profiles FOR SELECT TO authenticated USING (true);

-- سياسات جدول conversations
CREATE POLICY "Users can view conversations they are a member of." ON public.conversations FOR SELECT USING (
  id IN (
    SELECT conversation_id FROM public.conversation_members WHERE user_id = auth.uid()
  )
);

-- سياسات جدول conversation_members
CREATE POLICY "Users can view members of their conversations." ON public.conversation_members FOR SELECT USING (
  conversation_id IN (
    SELECT conversation_id FROM public.conversation_members WHERE user_id = auth.uid()
  )
);

-- سياسات جدول messages
CREATE POLICY "Users can insert their own messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can view messages in their conversations." ON public.messages FOR SELECT USING (
  conversation_id IN (
    SELECT conversation_id FROM public.conversation_members WHERE user_id = auth.uid()
  )
);

-- سياسات مخزن الصور (Storage Policies)
CREATE POLICY "Avatar images are publicly accessible." ON storage.objects FOR SELECT USING (bucket_id = 'avatars');
CREATE POLICY "Anyone can upload an avatar." ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars');
CREATE POLICY "Users can update their own avatar." ON storage.objects FOR UPDATE USING (auth.uid() = owner) WITH CHECK (bucket_id = 'avatars');


-- ==========[ المرحلة الثالثة: إنشاء الدوال المساعدة (RPC) ]==========

-- دالة لإنشاء محادثة خاصة (أو إرجاع الموجودة)
CREATE OR REPLACE FUNCTION public.create_private_conversation(other_user_id UUID)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    existing_conversation_id UUID;
    new_conversation_id UUID;
    current_user_id UUID := auth.uid();
BEGIN
    -- البحث عن محادثة خاصة موجودة بين المستخدمين
    SELECT c.id INTO existing_conversation_id
    FROM conversations c
    JOIN conversation_members cm1 ON c.id = cm1.conversation_id
    JOIN conversation_members cm2 ON c.id = cm2.conversation_id
    WHERE c.type = 'private'
    AND cm1.user_id = current_user_id
    AND cm2.user_id = other_user_id;

    -- إذا وجدت محادثة، أرجع المعرف الخاص بها
    IF existing_conversation_id IS NOT NULL THEN
        RETURN existing_conversation_id;
    END IF;

    -- إذا لم توجد، أنشئ محادثة جديدة
    INSERT INTO conversations (type) VALUES ('private') RETURNING id INTO new_conversation_id;

    -- إضافة كلا المستخدمين كأعضاء في المحادثة الجديدة
    INSERT INTO conversation_members (conversation_id, user_id)
    VALUES (new_conversation_id, current_user_id), (new_conversation_id, other_user_id);

    RETURN new_conversation_id;
END;
$$;
COMMENT ON FUNCTION public.create_private_conversation(UUID) IS 'Creates or retrieves a private conversation between the current user and another user.';

-- دالة لجلب معلومات الطرف الآخر في محادثة خاصة
CREATE OR REPLACE FUNCTION public.get_conversation_partner(p_conversation_id UUID)
RETURNS TABLE(user_id UUID, username TEXT, full_name TEXT, avatar_url TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT p.id, p.username, p.full_name, p.avatar_url
    FROM profiles p
    JOIN conversation_members cm ON p.id = cm.user_id
    WHERE cm.conversation_id = p_conversation_id
    AND cm.user_id != auth.uid();
END;
$$;
COMMENT ON FUNCTION public.get_conversation_partner(UUID) IS 'Gets the profile of the other user in a private conversation.';


-- دالة لجلب قائمة محادثات المستخدم
CREATE OR REPLACE FUNCTION public.get_user_conversations()
RETURNS TABLE(
    conversation_id UUID,
    full_name TEXT,
    username TEXT,
    avatar_url TEXT,
    last_message_content TEXT,
    last_message_created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    current_user_id UUID := auth.uid();
BEGIN
    RETURN QUERY
    WITH last_messages AS (
        SELECT
            conversation_id,
            content,
            created_at,
            ROW_NUMBER() OVER(PARTITION BY conversation_id ORDER BY created_at DESC) as rn
        FROM messages
    )
    SELECT
        c.id AS conversation_id,
        p.full_name,
        p.username,
        p.avatar_url,
        lm.content AS last_message_content,
        lm.created_at AS last_message_created_at
    FROM conversations c
    JOIN conversation_members cm_self ON c.id = cm_self.conversation_id AND cm_self.user_id = current_user_id
    JOIN conversation_members cm_partner ON c.id = cm_partner.conversation_id AND cm_partner.user_id != current_user_id
    JOIN profiles p ON cm_partner.user_id = p.id
    LEFT JOIN last_messages lm ON c.id = lm.conversation_id AND lm.rn = 1
    WHERE c.type = 'private'
    ORDER BY lm.created_at DESC NULLS LAST;
END;
$$;
COMMENT ON FUNCTION public.get_user_conversations() IS 'Retrieves a list of the current user''s conversations with partner details and the last message.';
